# -*- org -*-
#+STARTUP: indent showall lognotedone
#+TODO: TODO(t) WIP(p) MAYBE(m) | CANCELED(c) DONE(d)
#+OPTIONS: tasks:todo

* DONE Features
CLOSED: [2012-03-22 Thu 18:05]
- CLOSING NOTE [2012-03-22 Thu 18:05] \\
  With all the planned features done or cancelled, we're feature-complete!
** DONE More autodiscovery
CLOSED: [2012-03-22 Thu 18:03]
- CLOSING NOTE [2012-03-22 Thu 18:03]
*** DONE UID/GID discovery
CLOSED: [2012-03-20 Tue 11:47]
Cached by default, should be able to turn of caching with the global
LOG_CEE_NOCACHE flag, and also with LOG_CEE_NOCACHE_UID flag.
*** CANCELED Thread-id discovery
CLOSED: [2012-03-22 Thu 18:02]
- CLOSING NOTE [2012-03-22 Thu 18:02] \\
  Not going to do it, it's more trouble than it's worth. We not only
  have to figure out at compile time whether the platform supports
  gettid(), at run time, we also need to figure out whether the kernel
  supports it.. No thanks. Interested applications can just use
  cee_syslog() and add it themselves.
Not cached by default, but can be turned on with
LOG_CEE_CACHE_TID. This is linux-specific, and glibc does not provide
a wrapper, so this also needs some configure-time discovery.
*** DONE Timestamp in the payload
CLOSED: [2012-03-21 Wed 14:20]
- CLOSING NOTE [2012-03-21 Wed 14:20] \\
  Use clock_gettime(), and format the string with full precision.
Not enabled by default, can be toggled on with LOG_CEE_TIMESTAMP. 
**** What precision do we want?
*** DONE Hostname in the payload
CLOSED: [2012-03-21 Wed 12:53]
- CLOSING NOTE [2012-03-21 Wed 12:53] \\
  Done, we use gethostname(), as that's the easiest that yields somewhat
  useful results.
Do we want it, at all? If so, cache gethostname() and be happy, or is
there any other, better way?
** DONE Formatting of discovered stuff
CLOSED: [2012-03-22 Thu 18:05]
- CLOSING NOTE [2012-03-22 Thu 18:05]
*** CANCELED Timestamp as long/long pair instead of formatted string?
CLOSED: [2012-03-22 Thu 18:03]
- CLOSING NOTE [2012-03-22 Thu 18:03] \\
  The text format will do. It has the advantage of being a single value,
  easily parsable and so on and so forth. Adding ts_sec and ts_nsec
  would make less sense out of the box. People can do that by setting
  LOG_CEE_NOTIME, and adding the info themselves.
The timestamp is formatted to a string now, which is a considerable
effort, and will need to be parsed back again. Do we want this? Or
should we add the timestamp as a ts_sec & ts_nsec pair?

It's probably best to stay with the string, though.

* DONE Documentation
CLOSED: [2012-03-22 Thu 12:27]
- CLOSING NOTE [2012-03-22 Thu 12:27]
** DONE cee-syslog(3)
CLOSED: [2012-03-22 Thu 12:27]
- CLOSING NOTE [2012-03-22 Thu 12:27] \\
  Manual page is now complete.
The main entry point of the documentation, will detail the purpose and
goals of the library, along with the functions and constants it
provides. cee_syslog(), cee_vsyslog(), cee_legacy_*(), cee_openlog()
and cee_setlogmask() will be aliases to this page - similar how the
syslog functions are documented. 

It makes much more sense to have a single page for them all.

* DONE Test suite
CLOSED: [2012-03-20 Tue 12:29]
- CLOSING NOTE [2012-03-20 Tue 12:29] \\
  Test suite is in place.
The test suite cannot test the syslog calls themselves, as that would
be way too hacky to do properly. So it will test cee_format() instead,
which is used by the syslog calls anyway.

** DONE Decide how to test the library
CLOSED: [2012-03-20 Tue 12:29]
- CLOSING NOTE [2012-03-20 Tue 12:29] \\
  It's decided, I'll do just that.
I believe the best way to test would be to re-parse the JSON, extract
the fields, and verify they're of the expected value and type.

* TODO Bugfixes
** TODO Missing va_copy() when passing around varargs
The way we pass around varargs is unsafe, and causes crashes on a few
systems where we would need to copy the thing around.

We need a way to get the post-message key-value pairs some other way,
or with using va_copy() and counting format strings and whatnot.
* TODO Examples
While the test suite will provide some easier examples, it would be
nice to have a bigger example program that show-cases all the function
calls, with detailed documentation about the pitfalls, too.

*** MAYBE Forked and threaded example?
Ideally, this example would also fork and thread, just to be able to
document how those things are affected.
